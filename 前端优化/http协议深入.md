### 浏览器的渲染过程
在当HTTP请求完，客户端拿到了服务端的返回的网页内容就要开始渲染网页

如下是对整个过程（请求->响应->渲染）的解析：
![](https://github.com/4lQuiorrA/FE_Journey/blob/master/image/qianduanyouhua/httpxuanran.png)

这个东西也叫做**Navigation timing**,这是w3c专门定义的一套api ,定义了从请求到得到数据，然后在进行渲染的一系列具体的标准流程
这些api用来干嘛？可以来帮我们分析问题，去定位性能的耗时。可以用来调试，看这个性能瓶颈到底在哪里。
1. 第一步是Prompt for  unload 提示卸载：当你的新页面要被请求的时候，旧页面要被卸载，但是这个时候还没有被卸载，在这一步之前就是敲下回车键
    1. navigationStart就是第一个事件也是整个`Navigation timing`的开始
    2. 立刻开始`redirectStart`
2. 第二部就是redirect 重定向：首先自己本地重定向（本地缓存）,首先判断本地需要被重定向还是不需要，如果不需要，则去找服务器，查询服务器是否要进行重定向，他有一个并行的过程：unload(卸载上一个页面，把页面给腾出来)
    1. 页面卸载也包括2个事件`unloadEnd`和`unloadStart`
    2. `redirectEnd`要注意这个仅仅进行了重定向，资源是还没有取到的
3. 第三步是App cache,取缓存，如果判断本地已经有当前内容的缓存的时候，从缓存里面取，就直接结束，直接跳过其他步骤，到Processing步骤
    1. 资源的取是从`fetchStart`开始的，浏览器没有就要去网络上找
4. 如果资源过期，就开始第四步dns，找到ip ,
    1. dns查询的快慢前端无法解决所以这个是一个优化的瓶颈
    2. 这个地方当由于一些不可描述的技术墙壁，如果没有梯子，请求到这里就停止了。
5. 找到ip之后，就开始tcp,建立连接，3次握手
    1. 等连接完成Http协议才开始奏效
    2. 首先`connectStart`连接了，但是还没有完全连接上，需要在进行一次`secureConnectStart`才真正算连接上，所以`secureConnectStart`是在tcp中间，这个就是`SSL`或者`TLS`
    3. `connectEnd`
6. 第六步开始发送请求，返回来之后，网络的东西就结束了  ，回来之后拿到的就是一个html骨架，这个骨架里面都是dom树（还不是真正的dom树，他现在只是一个文档）,找到他上面挂载的事件或者脚本，注册好这些事件，将这些信息解析出来之后放到内存里面（memory），然后要解析成对象（`domloading`）,`domInteractive`当dom树加载完成之后，要去加载内嵌的资源（js,css,image）要进行其他资源的请求，在这个地方可能会停下来，`domContentloaded` dom 内容被加载完了这个就是真真正正的被渲染完了，`domComplete` 文档处理完了
    1. 请求个响应也是一个瓶颈，受网络状况的影响
    2. 如果带宽不足，或者其他因素的影响，这个时候网络就会采取一些措施：将服务架设在离你最近的一台服务器上。
    3. 
7. 就会触发第一个事件（load）,然后其他的东西在交给显卡处理渲染，`loadEventStart`装载里面的事件，`loadEventEnd`事件加载完成（onload事件执行完毕），这个之后就是`render`要进行工作，将页面画到浏览器上

打开浏览器，检查元素，network，请求里面的waterflow后面的加载事件就是依靠`navigation timing`制作出来的


### DNS详解
DNS，域名系统，用于将域名转换成IP

顶级域名：baidu.com
二级域名：www.baidu.com
三级域名：xxx.www.baidu.com

域名服务器- 用来域名和ip转换

域名解析 (正向解析和反向解析)
正向解析：域名->ip
反向解析：ip->域名

![](https://github.com/4lQuiorrA/FE_Journey/blob/master/image/qianduanyouhua/yumingjiexi.png)

1. 客户端发送域名给运营商解析服务器,要知道全球最少好几十e个域名
2. 运营商首先要查本地缓存，如果有直接返回
3. 如果没有则需要访问根服务器（17台，在美国），掌握了根服务器，控制了互联网，因为运营商一旦找不到域名就要去跟服务器上找，如果在根服务器上对你的域名做了手脚，那你的域名就直接废了
4. 当向根服务发送请求报文，根服务器发现你的域名是以`com`结尾的， 根服务器只会返回比如`com`这样后缀的内容，然后告诉你去某某某服务器问，去查询一级域名。然后返回到运营商这里，然后去访问这个服务器（Tld Server）（com有com的tld服务器的，cn有cn的tld的服务器）。然后会返回一个一级域名（baidu.com）.然后只能去name server找
5. name server 就会返回详细的域名/ip对照表，域名和ip的信息表。
6. 实际上就是运营尚服务器在疯狂工作，。，所以说整个过程很长，所以现在DNS做了优化，在DNS上加了大缓存，主要做的是和`name Server`进行缓存同步

在阿里云服务器上设置域名，其实是在name server上设置域名，然后需要在全球的name server服务器进行同步，阿里云厉害就在阿里云可以在10分钟可以将全球的服务器进行同步完成。

根服务器只解析后缀，tld服务器解析一级域名，name server 解析的2，3，4，5，6...级服务器。
阿里云不仅仅是name server 其实是一整套。

如果自己设置阿里或者谷歌DNS是可以不用走运营商的这一栏的，在本地有一个hosts，这个就是配置自己电脑的一级域名，二级域名。。。

当买了域名之后，发现不会设置
记录类型（你的域名是用来干嘛的）

SOA 起始授权记录  一个区域解析哭有且只有一个SOA记录，而且放在第一条（一般不需要我们设置，一个库里面只有一个SOA记录）

A(主机记录)（只能解析ipv4） 用于名称解析的重要记录，将特定的主机名映射到对应的主机的ip地址上（你有一个域名，你要将域名绑定当vps上的时候，就可以用这个记录 ）

CNAME 别名记录    比如你申请了一个域名，你发现有几个域名跟自己的域名很像，怕被别人注册，就直接全部申请了，当你的一个域名指向了一个地方，这是时候其他的为了方便也同时指向这个地方。你有1，2，3，4四个域名如果你想使用A记录，你就需要把这个4个域名同时都写A记录，然后指向你的vps服务器或者物理服务器，。但是如果这个想更改你的vps地址指向阿里云服务器，你的域名服务器少的话，还好说，要是有个几十个域名，都能写死。所以这个时候就需要用到CNAME别名记录，首先将域名1指向你的服务器，然后2，3，4指向域名1，这个时候，你要更改服务器地址，只需要更改一个A记录就可以了，这个时候2，3，4就被称为是1的别名）

NS记录  保存下一级的域名信息。（意味着可以架设属于自己的域名服务器）

MX记录    用于接受电子邮件的服务器地址 用于设定电子邮件  指向自己的邮件服务器


IPV6  与A记录对应 将特定的主机号映射到一个主机ipv6地址


### TCP三次握手和四次挥手
讲到tcp三次握手和四次挥手就要说到iso7层架构的数据经过之后都要加一个头了

![](https://github.com/4lQuiorrA/FE_Journey/blob/master/image/qianduanyouhua/shujuchuanshu.png)
数据在往下传输的时候，每经历一层就要加一个头
应用层  AH
表示层  PH
会话层  SH
传输层  TH
网络层  NH
数据链路层 DT

到了物理层就不加了。在物理层的时候，就是以比特流的形式来传输的，也就是010101的形式

等从物理层向上传输的时候，每过一层就要去掉一个头
头有什么用呢：？？？
1. 为本层次服务的这是是一点
2. 第二点就是，每一个层都有自己独有的序列号

其实这一整个过程就是一个寄快递的过程

**tcp 协议模型详解**
osi中的层                      功能                                      TCP/IP协议族
应用层              文件传输，电子邮件，文件服务，虚拟终端       TFTP,HTTP,SNMP,FTP,SMTP,DNS,TELNET

表示层                数据格式化，代码转换，数据加密                           没有协议

会话层                 解除或建立与别的接点的联系                             没有协议

传输 层                    提供端对端的接口                                 tcp ,udp

网络层                     为数据包选择路由            ip ,icmp原始数据报（ping命令） ,rip   ospf ,bgp,igmp

数据链路层              传输有地址的帧以及错误检测                 SLIP  CSLIP   PPP ARP   RARP   MTU

物理层                以二进制数据形式在物理媒体上传输数据                     iso2110

osi有7层，tcp/ip只有5层，他在表示层和会话层是没有这个东西的

SLIP命令就是用在串口通信上的
PPP协议在我们网络拨号的时候用的就是PPP协议   
ARP就是IP地址和MAC地址的合成

### tcp协议头详解

![](https://github.com/4lQuiorrA/FE_Journey/blob/master/image/qianduanyouhua/tcpxieyitou.png)
**tcp协议头最少要占24个字节**
tcp协议凭什么知道要把数据送到那个端口上呢，这个时候，tcp协议头上就有两个重要的端口：source port（源端口 客户端的端口，这个地方填的端口一般由操作系统来决定的，一般是一个比较大的数字）和destination port（目的端口 ，这个是服务端口 ，大家都知道http默认打开的就是80端口，所以这个地方一般默认填的就是80），这两个东西各占两个字节 ，所以容纳的最大的端口数2^16-1

第二个地方就是：**Sequence Number(顺序号)**，这是一个整型数据，在java里面整型是占4个字节的，所以一般容纳的大小为2^32-1,因为我们发送的数据的时候，可能这个数据很大，如果我们直接把整个数据装成一个包直接发送出去，如果在传输的的过程除了问题，有一个字节丢了，那么这整个包就得重传。所以我们应该考虑分开传，那么问题来了，在数据的传输的过程中，路由可能不一致，每个路由的传输的速度不一样，就会导致先发出去的包后到，那怎么办呢，就跟搬家一样，一般贵重的东西走空运，便宜笨重的东西走陆运，这样的话才能保证经济实惠，但是空运过来的东西的速度一般要快于陆运，你的贵重的东西，一般要放到柜子里面，但是柜子还没来怎么办。所以在数据传输的时候，我们会把所有的块编成号：1，2，3，4....;如果3号先到了，就会把他放在一旁，然后等待1，2号的到来，1，2号来了之后，然后把他们组装在一起，如果8号先到了，他就会等其他包，但是这个时候不可能一直等的去，所以，过了一段的时间，他就会向客户端发一个通知，说几号包丢了，要求重发一份，客户端就会重新发一份，最后组装完成如果最后还是损坏了，那整个数据就发生了损坏。虽然传输的时候比较麻烦，但是可靠性更高。

**Acknowledgment Number**  应答号，这东西是用来干嘛的呢：当数据传输过程中发生了丢包，服务端就会将这个包的编号放到一个存放的地方，然后向客户端发送一条重发的指令，客户端接受到这个指令，整理好准备重新发送这个包，这时客户端除了发送这个包之外，还要发送一个应答号，这个东西就是存放了你丢包的编号，告诉服务端我发送的这个包是回应你刚才缺失的包发送的包

offset 偏移量
tcp头里面这些数据都是二进制数据

**三次握手 四次挥手**
![](https://github.com/4lQuiorrA/FE_Journey/blob/master/image/qianduanyouhua/sanciwoshousicihuishou.png)

保证tcp通信的可靠性。
说到tcp通信就要来比较一下：tcp和udp的差别
tcp相当于两个人端对端进行打电话：这个时候就需要你开始拨号，然后另一个人接起这个电话，然后你开始：喂！喂！喂！你要确保对方能听到你的声音，然后对象也要确认你能听到他的声音
udp
只负责发，不保证能不能收到，也不能保证能不能回应，就跟广播找人一样，不保证别人能给回复你

**三次握手详情**

谁发起通信谁是客户端，服务器从来不主动发起

1. 客户端发起一个SYN发起请求，这个时候就要开始编号了：`seq=x` 进行编号，顺序号x
2. 服务端收到这个请求，由于tcp是双向链接  所以服务器也要向客户端发送一个SYN请求：`seq =y`;同时发送一个应答号ACK = x+1;   顺序号y,客户端和服务端的顺序号，这两个顺序号是两个编号系统，两者分开维护 ，同时服务器要向客户端发送一个应答号ACK=x+1;服务器收到这个应答号才知道，这个请求是响应谁的。
3. 客户端收到了服务器返回的响应的链接请求`ACK=x+1`和链接请求`SYN=y`。然后还要向发送一个响应的应答号`ACK=y+1`。
为什么要加一，应该这个顺序号要不停的向上加一，顺序号是不能重复的，这个编码的一个标准

**客户端和服务端进行通信**


**四次挥手**

1. 客户端发送一个关闭链接 `FIN seq=x+2` 和`ACK=y+1`，告诉服务器，我这边的事干完了，你那里还有什么事吗？这次通信有2个含义：1. 通知服务器要断开请求；2. 询问服务器你的活干完了没有
2. 服务端收到这两个包的时候，会连发两个包`ACK x+2`  和 `FIN seq=y+1`来响应客户端请求，这两个包不能合并成一个，必须分开2个发送：服务器收到客户端的请求，就发送一个接受到了客户段的关闭请求的包`ACK=x+2` 这两个包的含义是：1. 告诉客户端，我接受了你的关闭请求，你可以不用继续发了。2. 然后服务器开始结尾的处理，清理掉垃圾，然后向客户端发送一个结束的请求`FIN seq=y+1`.这两个包必须分开来发，因为这两个包的发送是有时间差的，这段时间中，服务器正在收尾。
3. 客户端接受到了`FIN seq=y+1`关闭请求，然后向服务器发送一个应答号`ACK=y+2`  然后正式关闭链接。
这个时候就涉及到了双工双向通信的功能了：
首先是单工双工的概念：
单工：只能单向通信。
双工：可以互相通信。

### cdn
资源分发网络，可以帮助提速
![](https://github.com/4lQuiorrA/FE_Journey/blob/master/image/qianduanyouhua/cdn.png)
左边是没有cdn加速的，右边的是有cdn加速的
左边的是完全中心化的，由于距离以及各种传输媒介，在传输过程中，难免会产生延迟，而且很多服务器重新访问一个服务器，这个服务器就太累了，甚至可能罢工，，为了解决这个问题，就开始使用镜像服务器，跨越的服务器少，自然速度就更快了

### 缓存机制    
缓存会根据请求保存输出内容的副本，例如：html页面，图片，文件，当下一个请求来到的时候：如果是相同的url，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求
缓存的优点：
- 减少响应延迟
- 减少网络带宽
网络是一种高消耗的io资源，不仅仅受限于网络的带宽，而且还受限于服务器的吞吐量（压力）

缓存的两大类：
- 强制缓存：不管你的资源，服务器要不要求要不要缓存下来都要缓存
- 对比缓存：通过比较来判断是不是要不要使用缓存

**强制缓存**
浏览器把资源推送过来，他不要求你一定要去缓存这个内容，但是还是为了这个缓存做了一些设置，就是给缓存的资源设置一个缓存
一般来说响应过来，缓存不缓存的话就比较随便了，如果缓存了，就一定要去比较有效时间，如果没有缓存就要去服务器请求资源

**对比缓存**

第一次请求
![](https://github.com/4lQuiorrA/FE_Journey/blob/master/image/qianduanyouhua/diyicitongxin.png)
- 第一次请求的时候，服务器会把资源和一些缓存标志都发送到客户端，客户端收到资源，然后根据服务器返回的缓存标志来判断是否要缓存到本地

再一次向服务器发送请求
对比缓存就不会像强制缓存一样，直接就对比时间戳了，而是一定要和服务器进行一次通信，让服务器去决定，你是否要去拉起这个资源。 

**对比缓存的两种策略：**
- Etag策略
- Last-Modified策略
**Etag策略**
由服务器给资源生成一个唯一的标志，而这个标志就放在Etag这个策略，等浏览器过期之后，客户端要将Etag拿出来，然后让服务器去确认这个是不是真的已经过期了 ，如果服务器发现Etag的确过期了，就会更新这个资源，返回一个200。如果发现没有过期，服务器就不会去更新资源了，这样的话，就会返回304本地跳转访问缓存
- Etag:web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识
- If-None-Match:当资源过期时（是用Cache-Control标识的max-age）,发现资源具有Etag声明，则再次向服务器请求时带上头`If-None-Match`（Etag的值）。web服务器发现有头`If-None-Match`则与被请求资源的相应校验串进行对比，决定返回200或者304。

**Last-Modified/If-Modified-Since策略**
- Last-Modified:标识这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。
- If-Modified-Since:当资源过期的时（使用Cache-Control标识的max-age），发现资源具有`last-Modified`声明，则再次向web服务器请求的时候带上头`If-Modified-Since`，表示请求时间。web服务器收到请求后发现有头`If-Modified-Since`则与被请求的资源最后的修改时间进行对比。若最后修改时间较新，说明资源又被修改过，则响应整片资源内容（写在响应消息包体里面），然后返回200，对缓存资源进行更新；若最后修改时间较旧，说明资源无新修改，则响应304（没有响应体，只有响应头），告诉浏览器继续使用所保存的cache.仅仅使用响应头，可以节省资源，让服务器可以响应更多的请求


其实很多情况下，这两种策略是会一起使用的
缓存策略一般配置在nginx

Etag的优先级高于Last-Modified
![](https://github.com/4lQuiorrA/FE_Journey/blob/master/image/qianduanyouhua/huancuncelv.png)

服务器决策：决策什么呢？就是判断当前缓存的时间是什么，缓存策略是什么。然后再进行一次缓存协商。


200 for disk cache  200 for memory cache,为什么会出现两种缓存
这是因为浏览器为了提高性能，提供了缓存分级的功能：就是把使用率高的资源放到内存里面，使用率不高的资源放到磁盘中，毕竟内存的访问速度要大于磁盘的访问速度。
有的时候disk资源会变成memory资源，memory资源也会变成disk资源：这就涉及到了一个命中率算法的问题，他会让一些网站访问量高的资源，临时提升到memory内，让资源更快的访问 ，所以内存里面的资源必须是高命中率的资源


