### 尾调用优化
> 指函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。。。

- 函数调用自身，称为递归。
- 如果尾调用自身，就称为尾递归

**在学习尾调用前，先了解一下尾递归和尾递归优化**
!递归需要保存大量的调用记录，很容易发生栈溢出错误，如果使用尾递归优化，将递归变成循环，那么只需要保存一个调用记录，这样就不会发生栈溢出

```
// 举个例子 斐波那契数列
function factorial(n){
    if(n===1) return 1;
    return n*factorial(n-1);
}

```
一个非常经典的尾递归调用的例子，但是这个例子的容易出现一个问题：栈溢出错误；为什么呢？再看一个例子

```
// 传统递归
function sum(n){
    if(n===1) return 1;
    return n+sum(n+1);
}

=>

sum(5)
5+sum(4)
5+sum(4+sum(3))
5+sum(4+sum(3+sum(2)))
5+sum(4+sum(3+sum(2+sum(1))))
5+(4+(3+(2+(1))))
5+(4+(3+3))
5+(4+6)
5+10
15
```
> 普通递归时，内存需要记录调用的堆栈所处的深度和位置信息，在最底层计算返回值，再根据记录的信息，跳到上一层级进行计算，然后再跳往更高一级，依次运行，直到最外层的调用函数，在CPU计算和内存会消耗很多，而且当深度过大时，会出现堆栈溢出。 
1.当sum调用5的时候，当前程序不知道运算了4之后的结果，所以要记录一个4的运算，然后调用4,但是找不到3运行之后的结果，依次类推

**补充：死循环和爆栈有什么区别吗**
1. 程序执行过程中由于各个流程间反复调用或无限循环地相互调用或调用时占用了太多资源，导致栈的空间不够使用了，其后引发的程序无法正常执行完毕的现象称为爆栈
2. 死循环主要关注于，一部分代码反复执行，阻塞了主线程，使得后续代码无法执行。


所以这个时候，应该对这种递归调用进行优化
```
function sum(n,total){
    if(n===1){
        return n+total
    }
    return sum(n-1,total+n);
}

sum(5,0);
sum(4,5);
sum(3,9);
sum(2,12);
sum(1,14);
15
```
整个计算过程是线性的，调用了一次sum(x,total)后，会进入下一个栈，相关的数据信息会跟随进入，不再放到堆栈上保存，当计算完最后的值之后，直接返回到最上层的sum(5,0),而这样优化，可以有效的防止堆栈溢出.

**在Esca script 6，就提到了尾递归优化**

**尾递归问题**
1. 尾递归的判断标准是函数运行[最后一步]调用自身，而不是在[最后一行]调用自身，而在最后一行调用其他函数，称为尾调用
```
// 要怎么理解呢？举个例子
function sum(n){
    if(n===1) return 1;
    return n+sum(n-1); // 这是在最后一行调用了自身，称为递归
}

function sum(n,total){
    if(n===1) return n+total;
    return sum(n-1,total+n) // 这是在最后一步调用了自身，称为尾递归。
}


function init(i){
    return test(i); // 最后一步调用了其他函数：尾调用
}
function test(i){
    init(i-1);  
}

```
2. 尾递归分为2种：浏览器版本的尾递归以及自己实现的尾递归
```
// 浏览器实现的尾递归,我们仍然来看一段老代码
function sum(n){
    if(n===1) return 1;
    return n+sum(n-1);
}
// 执行过程：
sum(5,0);
sum(4,5);
sum(3,9);
sum(2,12);
sum(1,14);
15
```
**如果浏览器使用尾递归调用优化的时候，会仅仅留下其中的一帧。缩减了大量的执行过程；因此在浏览器中只会执行这么一段：sum(1,14)**

我们来看看一段代码在浏览器中调用帧
```
function foo(n){
    return bar(n*2)            
}                           
function bar(){             
    // 查看调用帧             
    console.trace();    
}                   
foo(1);

=>
/左侧代码的⽬标
//只有⼀个执⾏栈
foo @ VM65:2 
(anonymous) @ VM65:10 
//强制指定 只留下bar当前执行的一帧
```

> 按道理尾递归调用调用栈永远都是更新当前的栈帧而已，这样就完全避免了爆栈的危险。但是现如今的浏览器并未完全支持的原因有二 1：在引擎层面消除递归是一个隐式的行为，程序员意识不到。2：堆栈信息丢失了 开发者难以调试。
3. 浏览器并没有实现尾递归，浏览器的尾递归需要强制开启,实现的方式有以下3种，虽然浏览器也没有实现这个功能
```
return continue 
!return 
#function() 
//遗憾的是浏览器并未⽀持
```

4. 一般来说尾部递归是我们自己实现的，尾递归是什么意思呢？整个执行过程向while看齐：即在我们操作中，能用while的就用while：因为while是一个线性执行的，不会留下堆栈执行记录

