### HTTP协议
http协议是网络协议的一种

#### HTTP模型
![http模型](https://github.com/4lQuiorrA/FE_Journey/blob/master/image/http/httpqingqiumoxing.png)

两个动作两个角色（Client(客户端),Server(服务端),请求（request）和响应（response））

当然在实际传输的过程中会经历很多内容：网络设备，代理。但是这些东西不会参与和干预到http请求中来，不应该算到模型中去。（除了劫持）

server（服务端）：比较常见的（apache）,tomcat,nginx（也能做服务器）

**浏览器与Http协议**
浏览器输入内容，到展示发生了什么？（较完整版）
![](https://github.com/4lQuiorrA/FE_Journey/blob/master/image/http/httpqingqiu.png)

1. 第一副图，用户在浏览器中输入“google.com”:让浏览器带他去google.com这个地方，浏览器干活之前，要去干很多事情
2. 首先要测试网络通不通，为什么要测试网络呢（HTTP协议是基于网络的，如果网络都不通，其他都白瞎），也就是说，浏览器要干的第一件事就是先穿透内网和外网 
3. 第二幅图：可以看到当前有一堵围墙，这个围墙就是网络边界，网络边界是什么概念。我们继续说：网络边界的外面是Internet（外网），里面是局域网；在网络边界上有一条门：这条门就是防火墙：防火墙作用就是控制数据包的进出。防火墙分为：软防火墙和硬防火墙，硬防火墙就非常的贵了，软防火墙就是软件了，可以装在PC上（linux也有防火墙叫做firewall）.防火墙就是一个策略，对发送的包或者接受包的一个策略，什么包可以接受，什么包不能接受。比如linux来讲，防火墙的功能就是调用了linux的网络功能。当然除了防火墙，还有路由，猫或者一个代理服务器。从这里可以看出来网络边界就是用来分割外网和局域网的边界，当然这个边界必须要有出口
4. DNS解析：域名是给人用的，而ip地址是给机器用的（相当于网络上的门牌号），人类通过记忆IP地址是一件相当困难的事情，所以需要一种手段去达到域名映射到ip地址的功能。而这个就是DNS服务器，首先浏览器要调用计算机自带的域名解析的功能，找到DNS服务器的ip，找到DNS服务器的IP地址后，浏览器向DNS服务器询问：“google.com”在哪，DNS服务器解析这个域名返回对应的IP地址，浏览器拿到这个地址，这个时候，网络就通了，浏览器会经历各种设备网关（linux（可以使用tracerouter）windows使用（tracert）来探知，浏览器在找寻所要找的IP地址时，所经过的ip地址）:

![](https://github.com/4lQuiorrA/FE_Journey/blob/master/image/http/traceroute.png)

我们看到了7，8，9，10是星号表示了，这种*号表示的是，当前经过的IP地址是无法探知到的，可能是走了岔路。

tracerouter跟ping包有关

![](https://github.com/4lQuiorrA/FE_Journey/blob/master/image/http/ping.png)

我们可以看到这上面有一个`icmp_seq` 的东西，这东西是属于数据链路层的内容，当数据经过一个路由之后，这个值就会+1，同时`ttl`就会减1，当这个数降到了0，这个数据包就会被丢弃。如果降到了0就证明数据包在网路上请求的时间已经太久了。

`ttl`在mac下默认为64

 	5. 完成了这些，就来到了对应IP的机房，然后请求就从对应的IP地址上进去，然后再通过反向代理，通过请求头上的信息，再决定将你的请求发到那个服务器进行处理，然后服务器响应。
 	6. 然后返回（返回的路不一定相等）
 	7. 然后浏览器解析响应的数据，将数据展示起来	

### HTTP协议

HTTP是什么？HTTP是超文本传输协议，从www浏览器传输到本地浏览器的一种传输协议，网站是基于HTTP协议，例如：网站的图片，CSS，JS等都是基于HTTP协议进行传输。

文本是二进制，超文本就是不止二进制文件，还包括其他的

HTTP协议是由从客户机到服务器的请求和从服务器到客户机的响应进行约束

HTTP0.9-HTTP2都是基于TCP协议的

HTTP是基于UDP协议的



#### TCP/IP协议栈

1. 应用层

   - 为用户提供所需要的各种服务，例如：HTTP、FTP、DNS、SMTP

2. 传输层

   - 为应用层实体提供端到端的通信功能，保证数据包的顺序传送及数据的完整性
   - 该层定义了2个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP）

3. 网络层

   - 主要解决主机到主机的通信问题，IP协议是网络互联层重要的协议

4. 网络接口层

   - 负责监视数据在主机和网络之间的交换

     

#### HTTP在TCP/IP协议栈中的位置

- 目前普遍应用版本HTTP1.1
- 正在逐步向HTTP2迁移
- HTTP默认端口为80 HTTPS默认端口号为443

    HTTPS其实就是在HTTP上做了一层加密
    
HTTP->TCP->IP->
HTTP 应用层协议 主要是HTTP1.1

TLS、SSL（加密）属于HTTP协议一个模块
HTTP:80
HTTP：443

###　HTTP的工作过程
事务，工作过程可分为四部（必须遵守）：一个操作需要诺干步，必须按照顺序执行，如果有一个失败，那么操作失败，只要操作符合这个过程就称为事务。
1. 客户机与服务器建立连接(tcp连接)。只需要单机某个超链接，HTTP工作开始。
2. 建立连接，C发送给请求给S，请求的统一格式：URL、版本协议号，后边是MIME信息包括请求修饰符，客户机信息和可能的内容，
3. 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号，一个成功或错误的代码，后边是MIME信息包括服务器信息，实体信息和可能的信息
4. 显示响应，断开连接

四步一步都不能错了，错了就报错，浏览器连接失败。

### 请求和响应

HTTP请求：请求行，消息报头 ，请求和正文。
HTTP响应组成:状态行，消息报头，响应正文
请求行组成：以一个方法符号开头，后面跟着请求URI和协议的版本
状态行组成：服务器HTTP协议的版本，服务器发回的响应状态代码和状态代码的状态描述。

Accpet接受什么样的数据类型
Accept-Encoding  表示接受的类型支持支持什么格式
Accept-Language：ZH-CN
Connnect 控制长连接（TCP层面上，多次请求，响应，在断开）还是短链接（每一次请求响应完都要断开）

HOST:
refer

都是不靠谱的，容易被伪造和修改

响应 
Server：Bws/1.1  远程服务器类型



最早的浏览器：netscape(网景)
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36


TCP属于IO操作


Cookie Session
Cookie一般是在服务端生成，只有极少数的情况用JS来控制

Session必须存在服务器端,原始的Session一般保存在内存中

Cookie的使用
与Cookie相关的HTTP扩展头
Cookie:客户端将服务器设置的Cookie返回到服务器中
set-Cookie：服务器向客户端设置Cookie
干净的浏览器和服务器交流

第一次访问：浏览器访问服务器。服务器设置set-Cookie:xxx
以后访问：浏览器就只需要带着Cookie访问服务器，然后跟据浏览器中的Cookie的合法性，返回响应


Session使用
实现方法：COOKIE;使用URL回显来实现（以URL上的TOKEN来实现，每一次访问：微信支付这样的就是使用URL）

第一次浏览器访问服务器：
1. 浏览器发送请求Request,服务器通过Cookie实现Session:set-Cookie:JSEESSIONID=XXX ：JSEESIONID代表java生成的SEESIONID

2. 浏览器第二次之后的访问，带上JSEESIONID发送给服务端
3. 服务器返回response


HTTP缓存机制

当资源第二次请求的时候，如果是相同的URL，缓存直接使用副本响应请求，而不是向源服务器再次发送请求

当浏览器向服务器发送请求，服务器发现当前缓存中有的话，就会返回一个没有请求头的304（not modified）

伪头(:)
仅仅就有5个伪头
4个请求
:method
:scheme 



协议协商（进行协议升级：将HTTP1.0升级到2）
HTTP提供了一个特殊的机制，这一机制允许讲一个已建立的连接升级成新的、不相容的协议（通常来说这一机制总是由客户端发起的（不过也有例外，比如说可以由服务端发起升级到传输安全协议TLS）），服务端可以选择是否升级到新协议，连接可以以常用的协议启动（如HTTP1.1）,随后再升级到HTTP2甚至是WebSockets

HTTP1.0是串行传输的

爬虫一般使用HTTP1

代理和反向代理

代理：用代理服务器将请求转发到不能到达的服务器（帮自己人转发）
白名单和黑名单策略

反向代理：互联网上有请求访问本地Ip,根据访问的不同的域名，来转发成不同的服务器