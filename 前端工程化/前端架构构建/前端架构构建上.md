### 什么是持续集成
持续集成（CI）
在持续集成的环境中，开发人员将会频繁的提交代码到主干。这些新提交在最终合并到主线之前，都需要通过编译和自动化测试流进行验证。这样做是基于之前的持续集成过程中很重视自动化测试验证结果，1以保证所有的提交在合并主干的质量问题，对可能出现的一些问题进行预警。

我们之前的流程是，我完成一个模块，然后人工告知QA说，我这边解决了，然后QA开始测试，出了问题，被打回，然后继续改，继续测，两个人疯狂的在那里打太极，严重降低了效率。
所以我们加入了持续集成（CI）.每一次，当前端代码提交到主线上的时候，都会自动跑自动化测试，等到自动化脚步跑了没错之后，才会合并到主分支，然后发消息通知QA来介入，这样就减少了很多QA和前端的交互

自动化提交代码，是程序员将代码提交到远程的一个服务器上，然后这个服务器上部署着webpack啊，自动化测试的脚本等等，然后等整个项目通过了自动化测试的脚本之后，然后通知测试，这时测试只负责一部分必须测试的内容，测试完通过之后，然后交付给CD,CD开始自动化部署

**持续部署（continuous deployment）简称CD**
- 如果我们想更加深入的话，就是持续部署了。通过这个方式，任何修改通过所有已有的工作流就会直接和客户见面。没有认为的干预（没有一键部署按钮），只有当一个修改在工作流中构建失败才能阻止他部署到生产线上
- 持续部署是一个很优秀的方式，可以加速与客户的反馈循环，但是会给团队带来压力，因为再也没有“发布日”了。开发人员可以专注于构建软件，他们看到他们的修改在他们完成工作的几分钟内就上线了，基本上，当开发人员在主分支合并一个提交时，这个分支将被构建、测试，如果一切顺利，则部署到生产环境上。

这个方法就在线下测试通过了，然后通过测试脚本，就会直接往线上部署，代替线上的代码。这样的过程对团队的压力很大，对公司的人员的硬实力要求很高。
实现这个方法的平台有：devops  可以理解成（softenginer,qa,technology operations）三个东西合并在一起了。这个东西最重要的部分就是CI


**持续交付（continuous delivery）**
- 持续交付就是讲我们的应用发布出去的过程，这个过程可以确保我们尽可能快的实现交付。这就意味着除了自动化测试，我们还需要自动化的发布流以及通过一个按钮就可以随时随地的实现应用的部署上线。
- 通过持续交付，你可以决定每天，每周，每两周发布一次，完全可以根据自己的业务进行设置
- 如果真的希望体验到持续交付的优势，就需要进行小批量的发布，尽快部署到生产线上，以便出现问题的时方便进行故障排除。


**持续集成的需求**
1. 持续集成是通过平台串联各个开发环节，实现和沉淀工作自动化的方法
2. 线上代码和代码仓库不同步，影响迭代和团队协作
3. 静态资源发布依赖人工，浪费开发人力
4. 缺少自动化测试，产品质量得不到保障
5. 文案简单修改上线，需要技术的介入。

一个项目上线的流程

![](https://github.com/4lQuiorrA/FE_Journey/blob/master/image/node/chixujichengliucheng.png)

- 首先立项
- 然后产品经历采集需求，需求文档编写完成之后，将需求文档放入到代码仓库里面
- 然后开发人员通过需求文档开发完了整个项目的代码，将代码放入到代码仓库里面
- 然后自动化构建平台就会从项目的代码仓库里面拉取代码（gitlab 既可以上传svn，也能上传git项目），拉取完代码之后，构建平台调用各色的构建工具（webpack,fis）之类的，开始对项目进行编译打包，项目构建完之后，部署到内网环境中，然后发消息通知qa去测试，qa开始测试自己的测试用例，测试通过之后，开始部署到外网环境，然后在运维和开发之间有个特殊的用户运营产品研发，这个角色，将体验用户带到特定的场所中，使用特殊的工具（如腾讯的：眼动仪），采集到用户的手喜欢点击整个屏幕的那个地方，和眼睛注意的主要区域。将这些信息采集完成之后，然后通知产品，针对这些内容再次进行需求修改，最后通知ui动画，重新设计，开发人员开始更改，最后重复自动化流程，最后上线。

**如果想要通过这个方式来构建项目需要以下的条件**
- 统一的代码仓库通过分支管理合并主干svn
- 自动化构建工具，编译，部署，测试，监控，本机开发上线环境。如：fis3/webpack/jdists/package.json//chai/supertest/mocha/selenium-webdriver
- 持续化集成平台：jenkins,travis ci
- 部署工具：rsync,shelljs,yargs
- 运营同学有权限操作运营页面保存即可上线。
### 什么是统一代码仓库

### 什么是前端工程化


### 什么是自动化构建
