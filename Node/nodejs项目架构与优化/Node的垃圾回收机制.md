### NodeJS内存管理机制及内存优化

要了解内存和回收首先要知道内存占用的具体情况

![](https://github.com/4lQuiorrA/FE_Journey/blob/master/image/node/V8huishoujizhi.png)

- RSS所有内存使用包括堆区和栈区
- heaptTotal堆区占用内存
- heapUsed已使用到堆部分
- external:V8引擎C++对象占用，（GC动态变化）

#### V8回收机制

- Node使用`javascript`在服务端操作大内存对象收到一定的限制（堆区），64位操作系统约为`1.4GB`,32位操作系统式`0.7GB`，**栈区新生代**64位是32M，32位是16M.

  为什么呢？比如，我们要上传一个文件：`4G`，上传之前，要在本地进行校验才能上传。如果本地文件超过1.4G，比如使用IO读取这个文件，这样就会操作不了，导致服务器直接挂，为什么`nodejs`操作不了大内存对象呢？因为node是给浏览器设计的，浏览器很正常的无法操作这么大的文件！所以V8没有做出处理，直到移植到Node里面来也没有解决这个问题

  虽然新生代的空间非常小，但是可以通过下面的指令，更改一个程序的新生代的大小或者老生代的大小

  node -max-new-space-size app.js 

  node -max-old-space-size app.js

- V8的垃圾回收策略主要基于分代式垃圾回收机制，在自动垃圾回收的演变中，人们发现没有任何一种垃圾回收算法能够胜任所有的场景。V8中内存分为新生代和老生代两代，新生代为存活时间较短的对象，老生代为存活时间较长的对象

  怎么解释分代式垃圾回收机制：小孩子随便玩，丢的垃圾，大人收。小孩<->程序;大人<->GC

  举个例子

  ```
  小孩在家玩玩具，有很多玩具，正常来说，父母会负责收拾孩子的玩具对吧，同时正常的父母都是，等小孩子玩具不玩了才开始回收把！总不能跟着屁股后面，边玩边收。这个时候，不玩的玩具会分成2种：一种：孩子一屁股做坏了，不能继续玩的，一种：孩子很喜欢玩的，很有可能等下会回来玩的。屁股做坏了的玩具，就属于那种，之后没法再玩的玩具了，所以，这个时候家长会回收掉这个玩具。但是很喜欢玩的玩具，家长就不会收走了，可能孩子要玩。这个喜欢玩的玩具就是存在家长这个老生代这里.当然如果玩具太多了,一个家长收拾不过来了,什么情况的玩具都有了,做坏的玩具,正在玩的玩具,喜欢玩的玩具.这个时候就需要2个家长一起来收拾了,父-新生代,母-老生代.母亲负责看着守着孩子喜欢玩,很有可能会继续玩的玩具.父亲,就负责收拾那些坏了的玩具和看着孩子正在玩的玩具。
  ```

#### Scavenge 算法

- 在分代基础上，新生代的对象主要通过`Scavenge`算法进行回收，在具体实现时，再具体实现时主要采用`Cheney`算法。`Cheney`算法是一种采用**复制**的方式实现的垃圾回收算法。他将内存一分为二，每一个空间称为`semispace`,这两个`semispace`中一个处于使用，一个处于闲置。处于使用的称之为`From`，闲置的称为`To`。分配对象时先分配到`From`，当开始垃圾回收的时，检查`From`存活对象并赋值到`To`，非存活被释放。然后互换位置。再次进行回收，发现被回收过直接晋升，或者发现`To`空间使用量打到了**25%**。这个算法缺点是只能使用堆内存的一半，这是一个典型的空间换时间的方法。**但是新生代声明周期较短，比较适合这个算法**

这段话什么意思呢？

示意图如下：

![](https://github.com/4lQuiorrA/FE_Journey/blob/master/image/node/scavengesuanfa.png)

1. 首先node将所有的代码都放到`from`里面
2. 当发现`From`的空间快要用完的时候，将正在使用的放到`to`中，没有在使用的就直接回收掉
3. 执行完之后，将`to`中的变量复制重新放到`From`里面
4. 等待再次重新开始123整个流程，如果发现当前`From`变量已经经历过多次回收的过程，则加入到**老生代**
5. 或者当`From`中的变量移交到`To`的时候，`To`中的使用空间已经打到了**25%**,则将这些变量放到**老生代空间里面**

这就是**新生代空间**的管理方式，接下来再看看老生代

老生代主要采用两种算法来确保内存的管理**Mark-Sweep&&Mark-compact**

- V8老生代主要采用**Mark-Sweep和Mark-compact**。再在老生代使用`Scavenge`不合适。一个是对象多需要赋值量太大而且没有解决空间问题。`Mark-Sweep`会在老生代空间标记那些已经死亡的对象，然后清除掉。但是清除掉的过程就会出现**内存不连续**，在内存中，如果内存不连续是非常浪费内存的：所以使用`Mark-compact`来解决**内存不连续的问题**，`mark-compact`是基于`Mark-sweep`演变而来的，他先将活着的对象移到一边，移动完成之后，直接清理边界外的内存。当CPU空间不足的时候，这种方法非常的高效。V8后续还引入了`延迟处理`,`增量处理`,并计划引入`标记处理`

![](https://github.com/4lQuiorrA/FE_Journey/blob/master/image/node/marksweep_markcompact.png)

- 就是先利用`mark-sweep`将一些死亡（以后不使用）的对象，先标记成星星号，然后将他们从内存中删除。这个时候就导致内存不连续了.
- 然后通过`mark-compact`将所有的对象移到右边（左边）,然后将左边（右边）的所有内存进行处理



####  何时会启动GC呢

![](https://github.com/4lQuiorrA/FE_Journey/blob/master/image/node/GCdeshihou.png)

- A是一个对象 ，B是一个对象，将他置为`null``
- ``ScanPoint`的代表扫描指针，`allocakePoint`代表分配指针，来为对象分配空间

变量从`From`移向`To`的过程

1. 首先扫描指针和分配指针在`To`的边缘是重合的
2. 然后扫描指针开始出门扫描`From`里面的变量，然后扫描到了`A`还在用，然后分配指针往后挪一个空间用来存放`A`，扫描指针继续扫描，分配指针继续往后挪，如果扫描指针遇到了`B`(也就是不使用的对象的时候，分配指针就不会挪位置)。这样的过程直到结束。扫描指针和分配指针再次重合
3. `From`的对象移到`To`用的是引用计数

值得提的是：

1. 最开始将`a`拷贝到To，这是分配指针不在于扫描指针重合，分配指针永远指向下一个可以分配的对象，扫描指针移动直到再次重合，GC结束。（广度优先）
2. 引用计数是计算机编程中的一种内存管理技术，是指将资源（可以是对象，内存或者磁盘空间）的引用次数保存次数，当引用次数变为零的时候就将其释放的过程。使用引用计数技术可以实现自动资源管理的目的，同时引用计数还可以指使用引用计数技术回收会使用资源的垃圾回收算法



总结：新生代回收的时机就是：`From`的空间被沾满。

#### 常见的内存泄露问题

- 无限增长的数组

- 无限设置的属性和值

- 任何模块内的私有变量和方法均是永驻内存的 a= null有的也无法解决如

  ```
  function Yideng(){}
  let y1 = new Yideng();
  y1 = null;
  // Yideng仍然存在于内存中无法消除
  ```

  

- 大循环，无GC的机会

####  内存泄漏分析

```
使用 node-inspector模块
console.log("server pid" process.pid);
sudo node --inspect app.js
while true; do curl "http://localhost:1337/" done;
top -pid 2322;
```

